\chapter{論理の形式化}
\label[chapter]{chap:formulize}

数理論理学が数学の一分野として成功を収めた要因のひとつとして，
素朴的直観を伴わない形式的な記号列を主役に据えたことが挙げられる．
ともすれば，このことは「数学で用いる論理について研究する分野」
という一般的な認識と矛盾するように見えることだろう．
実際，この「形式的な記号列」に関する議論の結果を根拠に
我々が普段使っている「論理」について何かを主張したい場合，
これらの間の橋渡しを行うのは主張したい当人の責任であり，
数理論理学の諸定理がその橋渡しについて何かを保証してくれることはない．
これは，理論物理学で得られた結果から現実世界について言及したり，
統計モデルの性質をもとに現実で得られたデータ（あるいはその生成元）に
ついて言及したりする営みに非常によく似ている．

もし読者にこのような「それそのものではないが何らかの意味で
関連性をもつと期待される概念の性質をもとに，目的の対象について議論する」
という営みに親しみがあれば，本章の内容は極めて身近に思えるに違いない．
そして，この手法が科学においていかに強力であるかを知っていれば，
数理論理学の手法がいかに強力であるかも予想できるだろう．


\section{数学における論理}
\label[section]{sec:logic}

数学が世界的に広く学ばれていることが示すように，
数学（および算数）を学ぶことは有益であるというのが一般的な認識である．
「なぜ数学を学ぶのか」という問いの答えは個々人によってさまざまだろうが，
少なくとも日本の数学教育学の分野では，
数学教育の目的は
\begin{enumerate}
	\item 陶冶的目的
	\item 実用的目的
	\item 文化的目的
\end{enumerate}
の3つの観点から論じられるのが一般的である%
\footnote{%
	念のため述べておくが，これは観点別評価とはまったく別の話である．
}%
．
このうち，実用的目的と文化的目的については字面から容易に想像できる通りの意味である．
すなわち，実用的目的は教科教育の内容そのものの修得と実社会における活用を志向したものであり，
文化的目的は文化としての学問を継承・発展させていくことを志向したものである．

一方で，1つ目の陶冶的目的についてはやや聞きなれない言葉である．
ここでの「陶冶」という言葉には「人の性質や能力を円満に育てること」という意味である．
すなわち，陶冶的目的というのは人間形成や価値観・（教科教育の内容以外での）能力を養成することを志向したものである．
具体例を挙げていけばキリがないが，「論理的思考力の養成」という目的は数学教育に明るくない人からでも
頻繁に挙がるものである%
\footnote{%
	ちなみに，価値観的な側面では「合理性を重んじる態度の養成」が挙げられる．
}%
．
なぜ数学を学ぶことで論理的思考力を養成できるのだと考えられているかといえば，
「数学」と「論理」の間に切っても切れない深いつながりがあるからに他ならない．
数学では，ある言明が「正しい」と主張したいとき，
なぜそうなるのかということの説明，すなわち「証明」が求められる．

\begin{Ex} \label[Ex]{Ex:simpleLogic}
	「6は偶数である」という言明が正しいと主張したいとする．
	この言明は以下のように「証明」できる：
	\begin{enumerate}
		\item 「偶数」とは「2の倍数，すなわち2の整数倍として表される整数」のことである．
		\item \(6 = 2 \times 3\)と表わされる．
		\item 3は整数である．
		\item 6は2の整数倍として表わされる．
		\item 従って，6は偶数である．
	\end{enumerate}
\end{Ex}

我々は\cref{Ex:simpleLogic}のような議論でもって「6は偶数である」という主張を「正しい」と認識する．
そして\cref{Ex:simpleLogic}のような議論ができないとき，我々は「それはおそらく正しくないのだろう」と認識する%
\footnote{%
	「誰がどうやってもこのような議論はできないのだ」ということを主張したければ，そのこともまた「証明」が求められる．
}%
．
また，数学においてはこの「証明」からあいまいさを極力排除することを求めるのも特徴的である．

\begin{Ex} \label[Ex]{Ex:ambiguousLogic}
	「円と楕円は位相同型である」という言明が正しいを主張したいとする．
	しかし，以下のような議論は通常「証明」とは認められない：
	\begin{enumerate}
		\item 2つの図形が位相同型であるというのは，一方を連続的に変形して他方と一致させることができることをいう．
		\item 円を少しつぶすことで楕円と一致させることができる．
		\item よって，円と楕円は位相同型である．
	\end{enumerate}
\end{Ex}

位相同型というものがどういうものか知らずとも，\cref{Ex:ambiguousLogic}のような議論が「うさんくさい」ことに気づくであろう%
\footnote{%
	このような体験をもとにして「数学では厳格な証明のみが許容されるのだ」などとは思ってはいけない．
	むしろ，\cref{Ex:ambiguousLogic}のような素朴的直観を精密化することによって厳格な証明を与えることも多い．
	許容されないのは，このようなラフな議論によって正しさの検証が完全に完結したかのように考えることである．
}%
．
例えば，
\begin{itemize}
	\item 「連続的に変形」とはいったい何をどうすることなのか
	\item 「少しつぶす」とはいったい何をどうすることなのか
\end{itemize}
あたりであろう．いずれも議論の中で使われている言葉の定義にあいまいさがあることに起因している．

言葉の定義にあいまいさがあること以外に，数学においては不適切であるとみなされる「証明」の例も挙げよう．

\begin{Ex} \label[Ex]{Ex:insufficientLogic}
	「すべての整数\(n\)に対して，整数\(n^2\)を3で割った余りは0か1である」という言明が正しいと主張したいとする．
	しかし，以下のような議論は通常「証明」とは認められない：
	\begin{enumerate}
		\item \(n = 2\)とする．\(n^2 = 4\)を3で割った余りは1である．
		\item \(n = 11\)とする．\(n^2 = 121\)を3で割った余りは1である．
		\item \(n = 30\)とする．\(n^2 = 900\)を3で割った余りは0である．
		\item 以上より，「すべての整数\(n\)に対して，整数\(n^2\)を3で割った余りは0か1である」ことが確かめられた．
	\end{enumerate}
\end{Ex}

\Cref{Ex:insufficientLogic}での議論では，それぞれの場面で言葉の定義があいまいさがある場所はなかった．
この議論が不適切であるとみなされるのは，ひとえに検証が不十分であることが要因である．
整数というのは無限に多く存在するのにもかかわらず，\(2, 11, 30\)の3つでしか検証していない．
残りの整数に対して一切言及していないにもかかわらず，
あたかもすべての整数に対して検証が終わったかのように議論を進めていることが問題である．
これらの実験は，もとの言明の「正しさの根拠」とはなりえない%
\footnote{%
	当然のことであるが，正しさの根拠にならないからといって「これらの実験は無価値である」などと思ってはいけない．
	このような実験は，数学という広大な世界を渡り歩いていくうえで学術的・教育的に極めて高い価値を有する．
	学習者にとって対象が未知であればなおさらである．
}%
．
すべての整数に対してもれなく検証を終えて初めて正しさが検証されたといえる%
\footnote{%
	愚直に行うのは当然不可能なので，検証には別の方法を考える必要がある．
	ポピュラーなのは，特定の整数に限定しない一般的な整数\(n\)を「任意に」とって，
	この\(n\)に対してだけ主張の正しさを検証することである．
}．

以上のように数学と論理との関係について振り返ってみると，例えば次のような疑問が浮かび上がってくる：
\begin{enumerate}
	\item 我々は，数学において「正しい」ことと「証明できる」ことを自然に同一視してしまっているが，それは適切なのだろうか？
	\item 我々は，数学における議論の進め方に適切なものとそうでないものがあることを知っている．その境界になっているものは何か？
	\item 数学における論理について，通常の数学と同じように何か一般的な法則や定理を見いだせないだろうか？
\end{enumerate}
これらの問いに完全な解答を与えるのは極めて困難であろう．
何を主張しても「そういう意見もあるよね」程度の立ち位置に落ち着いてしまいそうである．
「証明」や「正しさ」の意味するところがあいまいであることが解答の難しさに拍車をかけている．

数理論理学では，このあいまいさに対して一定の解決策を見出すことができる．
それは「論理そのものに対して直接議論することはせず，代わりに形式的な記号列について議論すること」である．
これがいったいどういうことなのかを次節以降で学んでいく．

\section{記号論理学} \label[section]{sec:symbolicLogic}

数学では，議論したい対象を表現するために記号を用いることが多い．
そして，記号化は単なる略記というだけでなくそれが意味するところを明確にするという役割も担うことがある．
典型的なのは文字である．

\begin{Ex} \label[Ex]{Ex:numericsymbol}
	「2」や「3」などのような特定の整数に対してではなく一般の整数に対して議論したいとき，
	「整数\(n\)」のように記号を用いて対象の整数を表現することが多い．
	「2」や「3」のような具体的な整数を表現する「数字」ではなく
	特に取り決めのない「文字」を使用することにより，「いまは特定の整数に限らない一般論を展開しているのだ」
	という意図がはっきりする．
	むろん「どんな整数に対しても」のように記号を使わず言葉で述べてもよいが，
	文章を書くのが相当に面倒になることは想像に難くない．
\end{Ex}

\Cref{Ex:numericsymbol}と同じことを数学における論理でも行うことを考える．
すなわち，「正しい」であったり「証明できる」という言葉の代わりに何らかの記号を用いるのである．
しかし，これでは単なる略記にしかなっておらず，あいまいさに対する解決策にはなっていない．
「何らかの主張\(A\)が正しいことを〇〇を表す」とか「\(\Gamma\)から\(B\)が証明できることを～と表す」
などと書いたところであいまいさが何一つ解消されてはいない．
これでは\cref{sec:logic}の最後で述べた問いへの解答とはなりえない．

ここで視点を変えて，「その記号は何らかの意味を有しているとは考えず，ただそこにあるのみである」
と考えてみよう．「2」や「3」という「数字」は我々にとって具体的な「数」を表すための記号であるが，
それはそれとして単に「2」や「3」のような形をした記号であるととらえることもできる．

\begin{Ex} \label[Ex]{Ex:objectsum}
	3つの記号\(2,3,+\)を書き並べた「\(2 + 3\)」という記号列を考える．
	素朴にはこの記号列を「これは2と3の和で5を表す」のように言いたくなるが，
	これを単なる記号列であると考える文脈においてはそのようなことはいえない．
	そもそも「5」という記号すら登場してはいないのである．
	この文脈においては，『記号「5」は記号列「\(2 + 3\)」の略記であると定義する』
	というように明示的に定義する必要がある．
\end{Ex}

\Cref{Ex:objectsum}のような議論を数学における論理についても適用してみよう．

\begin{Ex} \label[Ex]{Ex:objectLogic}
	「\(\Gamma\)から\(A\)を証明できる」と解釈できることを期待して，
	「\(\Gamma \sequent A\)」という記号列を導入する．
	この時点では，「\(\Gamma \sequent A\)」という記号列は単にそういう記号列であるというのみであり，
	「\(\Gamma\)から\(A\)を証明できる」などという意味は有していない．
	ただ単に我々がそう期待しているだけである．
\end{Ex}

このような記号の中で，数学的主張を構成するために使用される記号を特に%
\index[widx]{ろんりきごう@論理記号}%
\term{論理記号}と呼ぶことがある%
\footnote{%
	「論理記号」という言葉は「論理に関連した記号」程度の意味合いで雑に使われがちな言葉であり，
	数学者の間で共通認識があるわけではないようである．
	実際，\(\forall\)と\(\exists\)は%
	\index[widx]{りょうかし@量化子}%
	\term{量化子}と呼ばれることもある．
	「論理記号」の定義がないと困る場合にはその場で定義して使うようにすればよい．
}%
．
本書で扱う論理記号の一覧を\cref{tab:logicalsymbol}に示す．

\index[sidx]{\(\bot\)：矛盾}
\index[sidx]{\(\lnot\)：否定}
\index[sidx]{\(\land\)：連言（かつ）}
\index[sidx]{\(\lor\)：選言（または）}
\index[sidx]{\(\to\)：含意（ならば）}
\index[sidx]{\(\forall\)：全称（すべて）}
\index[sidx]{\(\exists\)：存在}
\begin{table}[htbp]
	\centering
	\caption{本書で登場する論理記号の一覧とその記号についての素朴的直観}
	\label{tab:logicalsymbol}
	\begin{tabular}{ccc}
		\toprule
		記号          & 素朴的直観   & 通常の数学における使用例                                   \\
		\midrule
		\(\bot\)    & 矛盾      & \(\bot\)：矛盾する                                  \\
		\(\lnot\)   & 否定      & \(\lnot A\)：\(A\)でない                           \\
		\(\land\)   & 連言（かつ）  & \(A \land B\)：\(A\)かつ\(B\)                     \\
		\(\lor\)    & 選言（または） & \(A \lor B\)：\(A\)または\(B\)                     \\
		\(\to\)     & 含意（ならば） & \(A \to B\)：\(A\)ならば\(B\)                      \\
		\(\forall\) & 全称（すべて） & \(\forall x \varphi\)：すべての\(x\)に対して\(\varphi\) \\
		\(\exists\) & 存在      & \(\exists x \varphi\)：\(\varphi\)となる\(x\)が存在する \\
		\bottomrule
	\end{tabular}
\end{table}

\(\forall\)や\(\exists\)のような論理記号は，
現代的にはこのような直感を捨てて純粋な記号列に対する議論であることを明示するために導入される．
従って，『「\(\forall x \varphi\)」は「すべての\(x\)に対して\(\varphi\)」という意味である』のような言明は
厳密には誤りであり，しかもその誤りは本質的なものである%
\footnote{%
	特に数理論理学と関係ない分野では，そのように導入したところで不都合は生じない．
	リアルタイム性が要求されるセミナーや講義の場等では書く文字数が少ない論理記号は便利である．
	一方で，数理論理学がこれだけ市民権を得ていることを考えれば，
	数学を専門とする人くらいは論理記号が単なる略記表現でないことを認識しておくべきであろう．
	その上で，時間の節約という目的であえて濫用するのであれば，そのことについてはまったく問題ないと考えられる．
}%
．



このような立場に立つと，数学で使う論理にかかわるさまざまな概念が
素朴的直観の伴わない形式的な記号列やそれに対する操作として「翻訳」できることに気づく．
そして，そのような「記号列への操作ゲーム」が有する性質を調べるのは数学が得意とするところである．
数理論理学も発展して久しく，現在ではさまざまな流儀や理論が存在するが，
本書では数学で使う論理にかかわるさまざまな概念を形式的な記号列やそれに対する操作として
「翻訳」する作業を体験することを目的とし，次章以降では話題を相当に絞って解説する．
数理論理学の広大な世界については，他の本を参照されたい．



\section{メタとオブジェクト} \label[section]{sec:metaobject}

数理論理学では，形式的な記号列やその操作に関する数学的性質を研究する．
このとき，集合や写像といった数学での道具は通常通り使用する．
これは，形式的記号列の世界の中で構成した「集合論」の性質を研究する場合でも変わらない．
循環論法になっているかのように思えるが，研究対象は集合論そのものではなくそれを模した
形式的記号列への操作ゲームなのだから，循環論法になっているわけではない．
一方で，そのような議論の中では自分が今どちらの立場なのか混乱しがちである．

本書では形式的記号列の世界での「集合論」は取り扱わないが，等号「\(=\)」については取り扱う．
形式的記号列の世界でも等号が登場するので，容易に区別をつけるために形式的記号列の世界における等号を%
\index[sidx]{\(\objeq\)：オブジェクト側における等号}%
\begin{align}
	\objeq
	\label{eq:objeq}
\end{align}
のように書き表しておくこととする．

上記のように，議論の対象として登場する理論や言語を%
\index[widx]{オブジェクト@オブジェクト}%
\term{オブジェクト}側であるといい，
議論のために用いている理論や言語を%
\index[widx]{メタ@メタ}%
\term{メタ}側であるなどということがある．
形式的記号列の世界での「集合論」を扱う文脈では，
その形式的記号列の世界での「集合論」がオブジェクト側であり，
研究のための道具として用いている集合論がメタ側である．

以降，本書では扱う記号がメタ側なのかオブジェクト側なのかを明示することを目的として，
オブジェクト側での記号はタイプライタ体で「%
\index[sidx]{\(\obj{x}\)：オブジェクト側の記号}%
\(\obj{x}\)」のように表し，
メタ側での記号は通常通り「%
\index[sidx]{\(x\)：メタ側の記号}%
\(x\)」のようにイタリック体で表す．

\section{整礎な半順序と整礎帰納法} \label{sec:well-founded}

ここで少し話題を変えて，数学的準備として整礎な半順序と整礎帰納法について述べておく．
以後，\(x, y\)からなる順序対\(\Set{\Set{x}, \Set{x, y}}\)を%
\index[sidx]{\(\pair{x, y}\)：順序対}
\(\pair{x, y}\)と表すことにする．
これを一般化した\(x_1, x_2, \dots, x_n\)からなる順序対も同様に\(\pair{x_1, x_2, \dots, x_n}\)と表記する．

\begin{Def} \label{Def:preorderedset}
	\(X\)を集合，\(\mathord{\prec} \subset X \times X\)を\(X\)上の二項関係とする．
	\(\pair{x, y} \in \mathord{\prec}\)であることを\(x \prec y\)と表記する．
	このとき，\(\mathord{\prec}\)が\(X\)上の%
	\index[widx]{はんじゅんじょ@半順序}%
	\term{半順序}であるとは，
	以下の条件がすべて満たされることをいう：
	\begin{enumerate}
		\item すべての\(x \in X\)に対して\(x \not \prec x\)である．ただし，\(x \not \prec x\)とは\(x \prec x\)が成り立たないことをいう．
		      この性質を%
		      \index[widx]{ひはんしゃせい@非反射性}%
		      \term{非反射性}という．非反射性をもつ二項関係は非反射的であるという．
		\item すべての\(x, y, z \in X\)に対して，\(x \prec y\)かつ\(y \prec z\)ならば\(x \prec z\)である．
		      この性質を%
		      \index[widx]{すいいせい@推移性}%
		      \term{推移性}という．推移性をもつ二項関係は推移的であるという．
	\end{enumerate}
\end{Def}

\begin{Lemma} \label[Lemma]{lemma:transitiveclosure}
	集合\(X\)上の二項関係\(\prec\)が与えられたとき，\(\prec\)を含む推移的な\(X\)上の二項関係\(\prec'\)で
	包含関係に対して最小のものが存在する．
	これを\(\prec\)の%
	\index[widx]{すいいへいほう@推移閉包}%
	\term{推移閉包}という．
\end{Lemma}

\begin{Que} \label[Que]{que:transitiveclosure}
	\Cref{lemma:transitiveclosure}を証明せよ．
\end{Que}

\begin{Def} \label{Def:well-foundedset}
	\(X\)を集合，\(\mathord{\prec}\)を\(X\)上の半順序とする．
	このとき，\(A \subset X\)について，\(A\)の元\(a\)が\(A\)の%
	\index[widx]{きょくしょうげん@極小元}%
	\term{極小元}であるとは，
	\(x \prec a\)となる\(x \in A\)が存在しないことをいう．
	また，\(\prec\)が\(X\)上で%
	\index[widx]{せいそ@整礎}%
	\term{整礎}であるとは，\(X\)の空でない任意の部分集合\(A\)が必ず極小元\(a \in A\)をもつことをいう．
\end{Def}

整礎な二項関係においては，以下に述べる整礎帰納法が重要である．

\begin{Thm}[整礎帰納法] \label[Thm]{Thm:well-foundedinduction}
	\(X\)を集合，\(\mathord{\prec}\)を\(X\)上の整礎な半順序であるとする．
	このとき，\(A \subset X\)が
	「\(x \in X\)を1つとるとき，\(y \prec x\)を満たすすべての\(y \in X\)に対して\(y \in A\)を満たすのであれば\(x \in A\)である」
	という条件を満たすのであれば\(A = X\)である．
\end{Thm}

\begin{proof}
	定理の主張が成り立たない，すなわち
	「\(x \in X\)を1つとるとき，\(y \prec x\)を満たすすべての\(y \in X\)に対して\(y \in A\)を満たすのであれば\(x \in A\)である」
	という条件を満たすにもかかわらず\(A \neq X\)であるとする．
	このとき，差集合\(X \setminus A\)は空でないため，その極小元\(x \in X \setminus A\)がとれる．
	\(x\)が\(X \setminus A\)の極小元であることから，\(y \prec x\)を満たす\(y\)はすべて\(A\)の元である．
	よって\(x \in A\)でなければならないが，これは\(x \in X \setminus A\)に矛盾する．
\end{proof}

\Cref{Thm:well-foundedinduction}において，集合\(A\)を「\(x \in X\)が与えられた性質を満たすときに\(x \in A\)とする」
のように決めておけば，\cref{Thm:well-foundedinduction}は\(X\)の元に関する何らかの性質の証明に活用することができる．

帰納法は性質の証明だけではなく対象の定義にも活用できるというのはよく知られた話である．
ここで導入した整礎帰納法ももちろんそうである．

\index[widx]{きのうてきていぎ@帰納的定義}
\begin{Thm}[帰納的定義] \label[Thm]{Thm:inductivedifinition}
	集合\(X, Y\)と\(X\)上の整礎な半順序\(\prec\)が与えられ，さらに
	写像\(G \colon \bigcup _{x \in X} Y^{\Set{y | y \prec x}} \to Y\)が与えられたとする．
	このとき，写像\(f \colon X \to Y\)で任意\(x \in X\)に対して
	\begin{equation}
		\apply{f}{x} = \apply{G}{f \restriction \Set{y | y \prec x}}
		\label{eq:inductivedifinition}
	\end{equation}
	を満たすものがただ1つ存在する%
	\footnote{%
		写像\(f \colon X \to Y\)と\(A \subset X\)に対し，%
		\index[sidx]{\(f \restriction A\)：写像の制限}%
		\(A\)から\(Y\)への写像\(a \mapsto \apply{f}{a}\)を\(f \restriction A\)で表す．
	}%
	．
\end{Thm}

\begin{proof}
	長くなるので概要のみ示す．

	一意性については容易に示すことができる．任意の\(x \in X\)に対して\cref{eq:inductivedifinition}を満たす
	写像\(f, g \colon X \to Y\)を任意にとったとき，任意の\(x \in X\)に対して\(\apply{f}{x} = \apply{g}{x}\)が成り立つことを
	整礎帰納法によって示せばよい．

	存在性については以下のように示すことができる．まず
	「写像\(f \colon \Set{y \in X | y \prec x} \to Y\)で任意の\(y \in X\)に対して
	\(\apply{f}{y} = \apply{G}{f \restriction \Set{z | z \prec y}}\)となるものが
	存在する」
	という主張が任意の\(x \in X\)に対して成り立つことを整礎帰納法によって示す．
	そのような写像は各\(x\)ごとに一意に定まるので，これを\(f_x\)と表すことにする．
	すると，
	写像\(f \colon X \to Y\)を以下のように定義できる：
	各\(x \in X\)に対し，\(x \prec y\)となる\(y \in X\)が存在しなければ
	\(\apply{f}{x} = \apply{G}{f_x}\)とする．そうでない場合，
	\(X\)の空でない部分集合\(\Set{y \in X | x \prec y}\)の極小元\(z\)をとり，
	\(\apply{f}{x} = \apply{f_z}{x}\)とする．
	この写像\(f\)は任意の\(x \in X\)に対して\cref{eq:inductivedifinition}を満たしている．
\end{proof}

\Cref{Thm:inductivedifinition}は，整礎な二項関係をもつ集合\(X\)から任意の集合\(Y\)への写像\(f\)を
定義するとき，各\(x\)に対する\(\apply{f}{x}\)を直接与えるのではなく\(y \prec x\)を満たす\(y \in X\)
に対する\(\apply{f}{y}\)から\(\apply{f}{x}\)を与える手続きさえ与えておけば，
それによって\(f\)が定義できることを主張している．

ここで特徴的なのは，\(x \in X\)に対する\(\apply{f}{x}\)を定義するのに別の\(y \in X\)に対する\(\apply{f}{y}\)を使っていることである．
このような形式でなされる定義を%
\index[widx]{きのうてきていぎ@帰納的定義}%
\term{帰納的定義}，
あるいは%
\index[widx]{さいきてきていぎ@再帰的定義|see{帰納的定義}}%
\term{再帰的定義}という%
\footnote{%
	\Cref{Thm:inductivedifinition}における再帰的定義では
	\(x \in X\)に対する\(\apply{f}{x}\)を定義するのに使用される\(\apply{f}{y}\)が
	\(y \prec x\)なる\(y \in X\)の\(f\)による像に限定されている．
	このような場合の「再帰的定義」は特に「原始再帰」と呼ばれる．
	また，本書では「帰納」と「再帰」同じ意味であるとして扱ったが，
	そうみなさないような文脈もある．
	「原始再帰」と「再帰」の違いや「帰納」と「再帰」に差異が生じる文脈については本書では取り扱わない．
}%
．

形式的な記号列を議論の対象にするうえで，\cref{Thm:well-foundedinduction}や
\cref{Thm:inductivedifinition}は非常に強力な武器となる．
具体例は本書全体にわたって現れるが，\cref{sec:formallanguage}においてはていねいに取り上げることとする．

\begin{Que} \label{que:proofinductivedefinition}
	\Cref{Thm:inductivedifinition}の証明を精密化せよ．
\end{Que}

\section{形式言語} \label{sec:formallanguage}

\Cref{sec:symbolicLogic}で述べたように，
今後我々が議論の対象とするのは「意味」をもたない形式的な記号列である．
まずはこの「形式的な記号列」の数学的定式化を述べておく．
以後，「自然数」といえば0も含むので注意されたい．%
\index[sidx]{\(\Natural\)：自然数全体の集合}%
また，自然数全体の集合を\(\Natural\)と表記する．

\begin{Def} \label{Def:formallanguage}
	記号の集合\(\Sigma\)が与えられたとする．\(w\)が\(\Sigma\)上の%
	\index[widx]{もじれつ@文字列|see{記号列}}%
	\term{文字列}%
	，あるいは%
	\index[widx]{きごうれつ@記号列}%
	\term{記号列}%
	であるとは，自然数\(n\)が存在して，\(w\)が
	集合\(\Set{0, 1, \dots, n-1}\)から\(\Sigma\)への写像であることをいう%
	\footnote{%
		集合\(\Set{0,1,\dots, n-1}\)は，集合論的には自然数\(n\)そのものである．
	}%
	．
	ただし，\(w\)が\(\Sigma\)への空写像%
	\footnote{%
		任意の集合\(A\)に対して，始集合が空集合\(\emptyset\)で終集合が\(A\)であるような
		写像\(f \colon \emptyset \to A\)はただひとつ存在する．%
		\index[widx]{くうしゃぞう@空写像}%
		この写像\(f\)を\(A\)への空写像と呼ぶ．
	}%
	である場合も含むものとする（このとき，上でいう自然数\(n\)は0とする）．
	このような自然数\(n\)は存在すれば一意である．

	また，記号列\(w \colon \Set{0, 1, \dots, n-1} \to \Sigma\)について，\(n\)を\(w\)の%
	\index[widx]{ながさ@（記号列の）長さ}%
	\term{長さ}%
	といい，%
	\index[sidx]{\(\length{w}\)：（記号列の）長さ}%
	\begin{equation}
		\length{w}
		\label{eq:lengthforstring}
	\end{equation}
	と表す．
	\(\Sigma\)上の長さ\(n\)の記号列\(w\)が
	\(\apply{w}{0} = s_0, \apply{w}{1} = s_1, \dots, \apply{w}{n-1} = s_{n-1}\)
	と定義されている場合，\(w\)を\(s_0, s_1, \dots, s_{n-1}\)を書き並べて%
	\index[sidx]{\(s_0 s_1 \dots s_{n-1}\)：記号列の表記}%
	\begin{equation}
		s_0 s_1 \dots s_{n-1}
	\end{equation}
	と表すことが多い．
	\(n = 0\)の場合，この表記法では何も書けないが，便宜上%
	\index[sidx]{\(\emptystring\)：長さ0の記号列}%
	\begin{equation}
		\emptystring
		\label{eq:emptystring}
	\end{equation}
	と表記することとする．

	さらに，\(\Sigma\)上の記号列の全体\(\bigcup_{n \in \Natural} \Sigma^{\Set{0,1,\dots, n-1}}\)を
	\(\Sigma\)の%
	\index[widx]{Kleeneへいほう@Kleene閉包}%
	\term{Kleene閉包}%
	といい，%
	\index[sidx]{\(\KleeneClosure{\Sigma}\)：Kleene閉包}%
	\begin{equation}
		\KleeneClosure{\Sigma}
		\label{eq:KleeneClosure}
	\end{equation}
	と表す．
\end{Def}

\begin{Ex} \label[Ex]{Ex:formalstring}
	\(\Sigma\)を以下の3つからなる集合とする：
	\begin{enumerate}
		\item 数字：\(\obj{0}, \obj{1}, \obj{2}, \dots\)
		\item 加法を表す演算子記号：「\(\mathord{\obj{+}}\)」
		\item 左カッコと右カッコ：「\(\lparen\)」「\(\rparen\)」
	\end{enumerate}
	このとき，以下はすべて\(\Sigma\)上の記号列である：
	\begin{align*}
		\obj{0},                                                                 \\
		\obj{\lparen 1 + 2 \rparen},                                             \\
		\obj{\lparen \lparen \lparen 4 \obj+ 1 \rparen + 5 \rparen + 6 \rparen}, \\
		\obj{\rparen 4 + + \lparen \rparen 4 5 \lparen +}
	\end{align*}
\end{Ex}

\Cref{Ex:formalstring}からもわかるように，
単に「記号列」といっただけでは数学的に何らかの意味をもつと期待されるような記号列以外の記号列も含む．
そのため，数学における「論理」を対象に議論する際には単に使う記号を列挙するだけでは不十分で，
どのような記号列を「認める」のかを宣言する必要がある．
要するに，用意した記号に対して「文法」を定義して議論の対象となる文字列を確定させる必要がある．
このときによく使われる手法が帰納的定義である．例を挙げよう．

\begin{Ex} \label[Ex]{Ex:recursivedefinition}
	\(\Sigma\)を\cref{Ex:formalstring}で述べた記号の集合とする．
	このとき，数式を以下のように定義する：
	\begin{enumerate}
		\item \(\Sigma\)の元のうち，数字はすべて数式である．
		\item \(t_1, t_2\)が数式であるならば，記号列
		      \begin{equation*}
			      \obj{\lparen} t_1 \obj{+} t_2 \obj{\rparen}
		      \end{equation*}
		      は数式である．
		\item 以上の規則を有限回適用して得られるもののみが数式である．
	\end{enumerate}
	このとき，\cref{Ex:formalstring}で述べた記号列のうち1つ目から3つ目までは数式であるが，4つ目は数式ではない．
\end{Ex}

\Cref{Ex:recursivedefinition}においては「数式とは〇〇であるものをいう」という形式での定義は困難である．
そのため「\(\Sigma\)に属する数字からどのようにして数式全体が得られるか」という構成方法を述べることによって数式を定義している．
整礎な半順序がすでに定義されている状況下での定義ではないため\cref{Thm:inductivedifinition}
を即座に適用できるわけではないが，何が数式で何が数式でないかは明確に定まっており，
この定義は定義として正当なものである．

また，最後に「以上の規則を有限回適用して得られるもののみが」と宣言することで，
上記の手続きで得られないものはすべてその定義からは外れていることを宣言し，
対象の範囲を確定させている．この宣言がないと
実際に定義したいものよりも広い範囲の対象が定義から外れることが明文化されない
\footnote{%
	例えば，偶数全体の集合\(A\)を「\(0 \in A\)であり，\(n \in A\)ならば\(n + 2 \in A\)かつ\(n - 2 \in A\)である」などとして
	定義しようとしたとき，整数全体の集合\(\Zahlen\)もカギカッコ内の条件自体は満たしている．
}%
．
とはいえ，この形式での定義においてこの宣言が必要なくなることはありえないので，自明であるとして省略されることも多い．

\begin{Note}
	プログラミングに近しい文脈では，\cref{Ex:recursivedefinition}における帰納的定義を
	\begin{equation*}
		\anglebrackets{\text{数式}} \Coloneq \anglebrackets{\text{数字}} \mathbin{|}
		\paren{\anglebrackets{\text{数式}} \obj{+} \anglebrackets{\text{数式}}}
	\end{equation*}
	のように表記することがある．この表記はBNF記法と呼ばれている．
\end{Note}

\begin{Que} \label{Que:recursivedefinition}
	\Cref{Ex:recursivedefinition}で述べた数式の定義を集合論のことばで正当化してみよう．
	自然数\(n\)に対する集合\(L_n \subset \KleeneClosure{\Sigma}\)を，以下の条件を満たすように定義できることを示せば十分である：
	\begin{enumerate}
		\item \(L_0\)は数字全体の集合である．
		\item 各\(n\)について，任意の\(t_1, t_2 \in L_n\)に対して\(\obj{\lparen} t_1 \obj{+} t_2 \obj{\rparen} \in L_{n+1}\)を満たす．
		\item 各\(n\)について，\(L_{n+1}\)は\(L_n \subset L_{n+1}\)と上記2を満たす包含関係に関して最小の集合である．
	\end{enumerate}
	1, 2, 3をすべて満たす集合\(L_n\)の存在を示し，それを使って\cref{Ex:recursivedefinition}で述べた数式全体の集合\(L\)をつくれ．
\end{Que}

\begin{Note} \label[Note]{Note:recursivedefinitiondepth}
	単に数式全体の集合\(L\)をつくるだけであれば，以下の条件を満たす\(\KleeneClosure{\Sigma}\)の部分集合で包含関係に対して最小のものをとることによってもできる：
	\begin{enumerate}
		\item \(t\)が数字ならば\(t \in L\)である．
		\item 任意の\(t_1, t_2 \in L\)に対して\(\obj{\lparen} t_1 \obj{+} t_2 \obj{\rparen} \in L\)となる．
	\end{enumerate}
	このような集合\(L\)のなかで包含関係に関して最小のものは上記条件を満たす\(\KleeneClosure{\Sigma}\)の部分集合全体の共通部分をとることで得られる．
	共通部分がとれることは，\(\KleeneClosure{\Sigma}\)自身が上記1, 2を満たすことからわかる．

	しかし今回は，各\(t \in L\)に対して\(t \in L_{n}\)を満たす自然数\(n\)がとれるという事実が重要である．
	何が重要かは\cref{Que:well-foundedexample}で述べることとする．
\end{Note}

\begin{Que} \label{Que:well-foundedexample}
	\Cref{Ex:recursivedefinition}で述べた数式の定義からは自然に整礎な半順序が得られる．
	これを示そう．

	\Cref{Que:recursivedefinition}で述べた集合\(L\)について，
	\(L\)上の二項関係\(\prec\)を以下のように定義する：
	任意の\(t_1, t_2 \in L\)に対して
	\(t_1 \prec \obj{\lparen} t_1 \obj{+} t_2 \obj{\rparen}\)かつ
	\(t_2 \prec \obj{\lparen} t_1 \obj{+} t_2 \obj{\rparen}\)であり，
	各\(x, y \in L\)に対して\(x \prec y\)となるのは上記のみである．
	このとき，\(\prec\)の推移閉包\(\prec'\)は\(L\)上の二項関係として整礎な半順序であることを示せ．

	証明にあたっては，以下のことに注意するとよい：
	\Cref{Note:recursivedefinitiondepth}で述べたように，各\(t \in L\)に対して
	\(t \in L_{n}\)となる自然数\(n\)がとれる．そのため，そのような\(n\)のなかで最小のものをとることができる．
	この自然数\(n\)は\(t \in L\)に対して一意に定まるので，\(n + 1\)を\(t\)の複雑さと定義して
	\(\apply{\depth}{t}\)と表すことにすると，
	\begin{equation}
		t_1 \prec' t_2 \metaequivalent \apply{\depth}{t_1} < \apply{\depth}{t_2}
		\label{eq:recursivedefinitiondepthorder}
	\end{equation}
	が成り立っている．
	よく知られているように，自然数全体の集合\(\Natural\)上の通常の大小関係\(\mathord{<}\)は整礎であるから，
	それを使って\(\prec'\)の整礎を示すことができる．
\end{Que}

\begin{Note} \label[Note]{Note:recursivedefinitiondepthdef}
	\Cref{Que:well-foundedexample}
	における\(\apply{\depth}{t}\)は，帰納的定義における階層の「深さ」を表すものであると考えることができる．
	実際，\(t\)が数字である場合には\(\apply{\depth}{t} = 1\)であり，\cref{Ex:recursivedefinition}における規則2を
	1回適用するごとに\(\apply{\depth}{t}\)の値は1ずつ増加する．
\end{Note}

\begin{Que} \label[Que]{Que:recursivedefinitiondepth}
	\Cref{Que:well-foundedexample}における数式の複雑さを表す写像\(\mathalpha{\depth} \colon L \to \Natural\)は，以下の条件を満たすことを証明せよ．
	\begin{align}
		\apply{\depth}{t}                                           & = 1, \quad \text{(\(t\)が数字のとき)}
		\label{eq:Que:recursivedefinitiondepth_numeral}                                                                                                           \\
		\apply{\depth}{\obj{\lparen} t_1 \obj{+} t_2 \obj{\rparen}} & = \max\Set{\apply{\depth}{t_1}, \apply{\depth}{t_2}} + 1. \quad \text{(\(t_1, t_2 \in L\))}
		\label{eq:Que:recursivedefinitiondepth_inductionstep}
	\end{align}

	なお，この写像\(\depth\)は\cref{eq:Que:recursivedefinitiondepth_numeral}と
	\cref{eq:Que:recursivedefinitiondepth_inductionstep}を満たす写像として，
	\cref{Thm:inductivedifinition}を通して特徴づけることができる．
	しかし，そのようにして写像\(\depth\)を定義したい場合には，
	\cref{Que:well-foundedexample}とは異なる方法で\(L\)上の順序\(\prec'\)の整礎性を証明する必要がある．
\end{Que}

\cref{Que:well-foundedexample}における整礎な半順序\(\prec'\)は，\(L\)の構造から自然に与えられるものである．
このように，帰納的に定義した集合に付随して与えられる整礎な半順序についての整礎帰納法を
特に%
\index[widx]{こうぞうきのうほう@構造帰納法}%
\term{構造帰納法}と呼ぶ．

\begin{Que} \label{Que:inductivedifinition}
	\Cref{Thm:inductivedifinition}によって，\cref{Ex:recursivedefinition}で述べた
	集合\(L\)の元\(t\)に対する以下の定義を正当化せよ．

	数式\(t\)に対し，その大きさ\(\apply{\size}{t}\)を以下のように定義する：
	\(t\)が数字ならば，
	\[
		\apply{\size}{t} = 1
	\]と定める．
	\(t\)が数字以外のとき，\(t\)は2つの数式\(t_1, t_2\)を用いて\(\obj{\lparen} t_1 \obj{+} t_2 \obj{\rparen}\)
	と表されるので，\(t\)の大きさを\(t_1, t_2\)の大きさを用いて
	\[
		\apply{\size}{t} = \apply{\size}{t_1} + \apply{\size}{t_2} + 1
	\]と定める．
\end{Que}

\begin{Que} \label{Que:structuralinductionexample}
	任意の数式\(t\)に対し，
	\cref{Que:well-foundedexample}における数式の複雑さ\(\apply{\depth}{t}\)と
	\cref{Que:inductivedifinition}における
	数式の大きさ\(\apply{\size}{t}\)との間に成り立つ関係式
	\begin{equation}
		\apply{\size}{t} \leq 2^{\apply{\depth}{t}} - 1
		\label{eq:sizedepthinequality}
	\end{equation}
	を，数式の構造に関する帰納法（\(L\)上の整礎な半順序\(\prec'\)における整礎帰納法）によって証明せよ．
\end{Que}